;; Daniel Borchmann, 2010
;; This file is in the public domain.

;; This file shows some examples how to use conexp-clj for (very
;; limited) Fuzzy-FCA.

(require 'conexp.main)
(in-ns 'conexp.main)

(use 'conexp.contrib.fuzzy.sets
     'conexp.contrib.fuzzy.logics
     'conexp.contrib.fuzzy.fca)

;;; First play around with some fuzzy sets

;; This is the empty set

(def- fs-1 (make-fuzzy-set {}))

;; This set contains 1 with degree 0.2, 3 with degree 0.4 and so on

(def- fs-2 (make-fuzzy-set {1 0.2, 3 0.4, 4 0, 5 1}))

;; You may also specify ratios to make all computation exact (and you
;; can also use bigfloats for that)

(def- fs-3 (make-fuzzy-set {1 1/5, 2 4/7}))

;; Now you can ask for containment; note that fuzzy sets can be called
;; like ordinary functions

(fs-2 1) ; -> 0.2
(fs-2 6) ; -> 0
(fs-3 1) ; -> 1/5

;; More to come (set operations and the like)

;;; Fuzzy logics

;; Fuzzy logics come from t-norm and conexp-clj defines 3 norms:
;; Łukasiewicz, Gödel and Product t-norm. They can be used to rebind
;; the fuzzy operators f-star, f-impl, f-and, f-or and f-neg to their
;; corresponding functions. This is done using the with-fuzzy-logic
;; macro

(with-fuzzy-logic :product
  (f-impl (f-and 1.0 0.4) (f-or 0.4 0.234)))

;; That's it actually. Whenever an operation uses fuzzy operators just
;; make sure that a call to this operation is wrapped in a
;; with-fuzzy-logic call.

;;; Fuzzy FCA

;; Let's create a fuzzy context

(def- fuzzy-context
  (make-fuzzy-context [1 2 3 4] ; vector of objects
                      [1 2 3 4] ; vector of attributes
                      [0.1 0.2 0.3 0.4, ; vector of entries
                       0.5 0.6 0.7 0.8, ; , is a whitespace
                       0.9 1.0 0.9 0.8,
                       0.7 0.6 0.5 0.4]))

;; The only thing you can do by now is to compute fuzzy derivation as
;; used by Belohlavek and Vychodil

(with-fuzzy-logic :lukasiewicz
  (fuzzy-attribute-derivation fuzzy-context
                              (make-fuzzy-set {2 0.3, 4 0.8})))

;; Note that you can also directly use hashmaps here, since the
;; derivation operations automatically convert them to fuzzy sets if
;; possible

(with-fuzzy-logic :goedel
  (fuzzy-attribute-derivation fuzzy-context {2 0.3, 4 0.8}))

;; If you don't like rounding errors and you are willing to wait a bit
;; longer you can also use rationals (i.e. 1/2 instead of 0.5) or
;; BigDecimals (i.e. 0.5M instead of 0.5) when specifying the fuzzy
;; context.

;;;

nil
