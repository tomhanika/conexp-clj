;; Copyright â“’ the conexp-clj developers; all rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file LICENSE at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns conexp.fca.fuzzy.sets
  "Basic definitions for fuzzy sets"
  (:use conexp.base)
  (:require [clojure.math.combinatorics :as comb]
            [clojure.set :as set]))


(deftype Fuzzy-Set [^clojure.lang.APersistentMap hashmap]

  Object
  (equals [this other]
    (generic-equals [this other] Fuzzy-Set [hashmap]))
  (hashCode [this]
    (hash-combine-hash Fuzzy-Set hashmap))
  (toString [this]
    (str hashmap))

  clojure.lang.ISeq
  (first [this]
    (first hashmap))
  (next [this]
    (next hashmap))
  (more [this]
    (if-let [n (next hashmap)]
      n
      ()))
  (cons [this [k v]]
    (when-not (and (number? v) (<= 0 v 1))
      (illegal-argument "Fuzzy sets only support real values in [0,1]"))
    (if (zero? v)
      (Fuzzy-Set. (dissoc hashmap k))
      (Fuzzy-Set. (assoc hashmap k v))))
  (seq [this]
    (seq hashmap))
  (count [this]
    (count hashmap))
  (empty [this]
    (Fuzzy-Set. {}))
  (equiv [this other]
    (.equals this other))

  clojure.lang.IFn
  (invoke [this thing]
    (let [result (hashmap thing)]
      (or result 0)))
  (applyTo [this ^clojure.lang.ISeq seq]
    (if (= 1 (count seq))
      (.applyTo hashmap seq)
      (illegal-argument "Cannot apply fuzzy sets to non-singleton sequences.")))

  clojure.lang.Associative
  (containsKey [this o]
    true)
  (entryAt [this o]
    (.entryAt hashmap o))
  (assoc [this k v]
    (.cons this [k v]))

  clojure.lang.ILookup
  (valAt [this o]
    (get hashmap o 0))
  (valAt [this o not-found]
    (get hashmap o not-found)))

(defmethod print-method Fuzzy-Set [set out]
  (.write ^java.io.Writer out
          ^String (str "#F" set)))

(defmulti make-fuzzy-set
  "Constructs a fuzzy set from a given collection."
  clojure-type)

(defmethod make-fuzzy-set :default
  [thing]
  (illegal-argument "Don't know how to create a fuzzy set from " thing "."))

(defmethod make-fuzzy-set clojure-map
  [hashmap]
  (assert (forall [v (vals hashmap)]
            (and (number? v) (<= 0 v 1))))
  (Fuzzy-Set. (select-keys hashmap (remove #(zero? (hashmap %)) (keys hashmap)))))

(defmethod make-fuzzy-set Fuzzy-Set
  [fuzzy-set]
  fuzzy-set)

(defmethod make-fuzzy-set clojure-set
  [set]
  (Fuzzy-Set. (map-by-fn (constantly 1) set)))

(defmethod make-fuzzy-set clojure-coll
  [coll]
  (make-fuzzy-set (set coll)))

(defmethod make-fuzzy-set clojure-vec
  [vec]
  (make-fuzzy-set (set vec)))

(defn fuzzy-set-to-hashmap [fuzzy-set]
  "Returns a Hashmap Mapping each Element in the Fzuuy Set to its Membership Degree."
  (.hashmap ^Fuzzy-Set fuzzy-set))

(defn fuzzy-set? [thing]
  "Tests whether the argument is a fuzzy set."
  (instance? Fuzzy-Set thing))

;Set Operations
(defn fuzzy-intersection [a b]
  "Computes the intersection of fuzzy sets."
  (let [a-entries (set (map first a))
        b-entries (set (map first b))
        entries (set/union a-entries b-entries)]
    (make-fuzzy-set (into {} (for [x entries] [x (min (a x) (b x))]))))
)

(defn fuzzy-union [a b]
  "Computes the union of fuzzy sets."
  (let [a-entries (set (map first a))
        b-entries (set (map first b))
        entries (set/union a-entries b-entries)]
    (make-fuzzy-set (into {} (for [x entries] [x (max (a x) (b x))]))))
)

(defn fuzzy-difference [a b]
  "Computes the difference of fuzzy sets."
  (let [a-entries (set (map first a))
        b-entries (set (map first b))
        entries (set/union a-entries b-entries)]
    (make-fuzzy-set (into {} (for [x entries] [x (max 0 (- (a x) (b x)))]))))
)

(defn fuzzy-subsets [mvalues fset]
  "Receives a collection of membership degrees and a fuzzy set as arguments.
   Returns all fuzzy subsets of the supplies fuzzy sets that are generated by
   combining each element with each membership degree lesser or equal to its 
   original membership degree in the supplied fuzzy set."
  (let [mvalues (sort mvalues),
        fset (seq (make-fuzzy-set fset)),
        max-values (vec (map second fset)),
        crisp-base (map first fset)]
    (map #(make-fuzzy-set (zipmap crisp-base %))
         (apply comb/cartesian-product
                (for [i (range (count fset))]
                  (take-while #(<= % (nth max-values i)) mvalues)))))
)

(defn fuzzy-subset? [fset1 fset2]
  "Verifies whether *fset1* is a fuzzy subset of *fset2*."
  (forall [k (keys (fuzzy-set-to-hashmap fset1))]
    (<= (fset1 k)
        (fset2 k)))
)
