(ns conexp.fca.factorization
    (:require [conexp.base :refer :all]
              [conexp.fca.fast :refer [to-binary-matrix]]
              [conexp.fca.contexts :refer :all]))

(defprotocol factorization-protocol
  (context [this] "Returns the context that is generated after using the algorithm algo k-times on it")
  (object-factor [this] "Returns the object-factor of the context generated by the algorithm")
  (attribute-factor [this] "Returns the attribute-factor of the context generated by the algorithm"))

(defrecord factorization-record [context object-factor attribute-factor]
  factorization-protocol
  (context [this] context)
  (object-factor [this] object-factor)
  (attribute-factor [this] attribute-factor))

(defn- unite
"Unite-Operator for 2 matrices"
  [A B]
  (loop [i 0 C []]
    (if (>= i (count A))
      C
      (recur
        (inc i)
        (conj C (into [] (map (fn [x y] (if (or (= 1 x) (= 1 y)) 1 0)) (get A i) (get B i))))))))

(defn- make-object-helper
  "Helper function for make-object"
  [concept m k j]
  (loop [i 0 a []]
    (if (<= m i)
      a
      (recur 
        (inc i)
        (cond (some #(= i %) (get (get concept j) 0))
              (conj a 1) :else (conj a 0))))))

(defn- make-object
  "Creates Object Factorization Context from a given Concept given by Grecond & Greess Algo"
  [concept m k]
  (loop [i 0 out []]
    (if (<= k i)
      (make-context-from-matrix m k (into [](flatten (apply mapv vector out))))
      (recur
        (inc i)
        (conj out (make-object-helper concept m k i))))))

(defn- make-attribute
  "Creates Attribute Factorization Context from a given Concept given by Grecond & Greess Algo"
  [concept n k]
  (loop [i 0 j 0 out []]
    (if (<= k j)
      (make-context-from-matrix k n out)
      (recur
        (cond (>= i (- n 1)) 0 :else (inc i)) 
        (cond (>= i (- n 1)) (inc j) :else j)
        (cond (some #(= i %) (get (get concept j) 1))
              (conj out 1) :else (conj out 0))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; https://doi.org/10.1137/1.9781611972801.15;

(defn- calc-one-matrix
  "Calculates Matrix with 2 vectors"
    [A B]
    (into []
      (let [X []]
        (for [a A]
         (into X (for [b B] (if (and (= a 1) (= b 1)) 1 0)))))))    
  
(defn- calc-panda-context
  "Creates Context from panda-algo result vectors"
  [pi]
  (loop [i 0 end (calc-one-matrix (get (nth pi i) :ci) (get (nth pi i) :ct))]
    (if (>= i (count pi))
      (make-context-from-matrix  (count (get (nth pi 0) :ci)) (count (get (nth pi 0) :ct)) (into [] (flatten end)))
      (recur
        (inc i) 
        (unite end (calc-one-matrix (get (nth pi i) :ci) (get (nth pi i) :ct)))))))

(defn- create-new-d
"Returns new Matrix D from Input Matrix to adjust form already calculated vectors"
  [C Dr]
  (loop [i 0 A []]
    (if (>= i (count C))
      A
      (recur 
        (inc i)
        (conj A (into [] (map (fn [x y] (if (and (= 1 x) (= 1 y)) 0 y)) (get C i) (get Dr i))))))))

(defn- sort-items
"Returns sorted list S"
  [cur-D]  
  (loop [i 0 
         item (get cur-D 0)
         S (hash-map)]
    (if (>= i (count cur-D))
      S
      (recur 
        (inc i)
        (get cur-D (inc i))
        (assoc S i (cond (nil? (get (frequencies item) 1)) 0  :else (get (frequencies item) 1)))))))

(defn- create-new-ct
"Creates new Vector to loop over"
  [Ct Dr]
  (let [Cts []]
    (into Cts
      (for [i (range (count Ct))]
        (if (= 0 (get Dr i)) 0 (get Ct i))))))

(defn- count-one
"Returns count of 1's in Matrix"
  [V]
  (loop [i 0 c 0]
     (if (> i (count V))
      c
      (recur 
        (inc i)
        (cond (= (get V i) 1) (inc c) :else c)))))

(defn count-false-ones
  "Returns count of how many false 1's are in the Matrix"
  [V D]
  (loop [i 0 j 0 c 0]
    (if (>= i (count V))
      c
      (recur
         (cond (> j (count (get V 0))) (inc i) :else i)
         (cond (> j (count (get V 0))) 0 :else (inc j))
         (cond (not= (get (get V i) j) (get (get D i) j)) (inc c) :else c)))))

(defn- weight-core
  "Weight function to determine if found Core is better, additionally adds list sh to the new core"
  [C CS sh D]
  (let [count-onesCS (+ (+ (count-one (get CS :ci)) (count-one (get CS :ct)))
                       (count-false-ones (calc-one-matrix (get CS :ci) (get CS :ct)) D))
        count-onesC (+ (+ (count-one (get C :ci)) (count-one (get C :ct)))
                      (count-false-ones (calc-one-matrix (get C :ci) (get C :ct)) D))]
    (if (<= count-onesCS count-onesC) CS (update C :e conj sh))))

(defn- weight
  "Weight function to determine if found Core is better"
  [C CS D]
  (let [count-onesCS (+ (+ (count-one (get CS :ci)) (count-one (get CS :ct)))
                       (count-false-ones (calc-one-matrix (get CS :ci) (get CS :ct)) D))
        count-onesC (+ (+ (count-one (get C :ci)) (count-one (get C :ct))) 
                      (count-false-ones (calc-one-matrix (get C :ci) (get C :ct)) D))]
    (if (<= count-onesCS count-onesC) CS C)))

(defn- find-core-loop
  "Loops to find new Cores"
  [S C newD]
  (loop [CiS (assoc (get C :ci) (get (nth S 1) 0) 1)
         CtS (create-new-ct (get C :ct) (get newD (get (nth S 1) 0)))
         CS C
         i 1]
    (if (>= i (count S))
      CS
      (recur
        (assoc (get CS :ci) (get (nth S i) 0) 1)
        (create-new-ct (get CS :ct) (get newD (get (nth S i) 0)))
        (weight-core CS {:ci (assoc (get CS :ci) (get (nth S i) 0) 1)
                        :ct (create-new-ct (get CS :ct) (get newD (get (nth S i) 0)))
                        :e (get CS :e)} 
                       (get (nth S i) 0) newD)
        (inc i)))))

(defn- find-core
  "finds a core and returns new D"
  [cur-D]
  (let [S (sort-by val > (sort-items cur-D))
        C {:ci (assoc (vec (repeat (count cur-D) 0)) (first (first S)) 1)
           :ct (get cur-D (first (first S)))
           :e (list)}]
    (find-core-loop S C cur-D)))

(defn- new-transactions
  "Helper function for 'extend-core'"
  [C pi D]
  (loop [i 0 CS C]
    (if (<= (count (get C :ct)) i)
      CS
      (recur
        (inc i)
        (weight CS {:ci (get CS :ci) :ct (assoc (get CS :ct) i 1)} D)))))

(defn- extend-core
  "extend-cores with noise"
  [C pi D]
  (let [E (get C :e)]
    (loop [i 0 item (nth E 0) CS C]
      (if (<= (count E) i)
        CS
        (recur 
          (inc i)
          (nth E i)
          (new-transactions (weight CS {:ci (assoc (get CS :ci) item 1) :ct (get CS :ct)}
                                      D)
                            pi
                            D))))))

(defn- panda-factorization-matrices
  "Creates Object/Attribute Factorization from panda algo"
  [x n m k]
  (loop [i 0 cio [] cto[]]
    (if (<= k i)
      [(calc-panda-context x)
       (make-context-from-matrix n k (into [](flatten (apply mapv vector cio))))
       (make-context-from-matrix k m (into [](flatten cto)))]
      (recur 
        (inc i) 
        (conj cio (get (nth x i) :ci))
        (conj cto (get (nth x i) :ct))))))

(defn panda
  "Greedy Algorithm which searches for tupel (A,B) which cover the most incidences based on their derivation"
  [input k]
  (let [D (make-matrix-from-context (context-to-string input))]
    (loop [i 0 pi (list) cur-D D]
      (if (<= k i)
        (panda-factorization-matrices pi (count (get (nth pi 0) :ci)) (count (get (nth pi 0) :ct)) k)
        (recur 
          (inc i)
          (conj pi (extend-core (find-core cur-D) pi cur-D))
          (create-new-d (calc-one-matrix (get (extend-core (find-core cur-D) pi cur-D) :ci) 
                                     (get (extend-core (find-core cur-D) pi cur-D) :ct))
                      cur-D))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; grecond
;; https://doi.org/10.1016/j.jcss.2009.05.002

(defn grecond-make-matrix-from-concept
  "Creates Grecond Matrix when given concepts"
  [a b n m]
  (loop [i 0 j 0 matrix []]
    (if (> j (- m 1))
    matrix
      (recur 
        (cond (>= i (- n 1)) 0 :else (inc i)) 
        (cond (>= i (- n 1)) (inc j) :else j)
        (cond (and (some #(= j %) a) (some #(= i %) b)) (conj matrix 1) :else (conj matrix 0))))))

(defn- calc-grecond-context
  "Creates Context from grecond-algo result vectors"
  [F m n]
  (loop [i 1 
         end (grecond-make-matrix-from-concept (nth (nth F 0) 0) (nth (nth F 0) 1) n m)]
    (if (>= i (count F))
      (make-context-from-matrix m n end)
      (recur
        (inc i)
        (mapv (fn [x y] (if (or (= 1 x) (= 1 y)) 1 0))
              (grecond-make-matrix-from-concept (nth (nth F i) 0) (nth (nth F i) 1) n m) end)))))

(defn- grecond-match
  "Tests how much the chosen concept is covering"
  [A U]
  (loop [i 0 c 0 u U]
    (if (>= i (count A))
      {:u u :c c}
      (recur
         (inc i)
         (cond (= (get A i) (get U i) 1) (inc c) :else c) 
         (cond (= (get A i) (get U i) 1) (assoc u i 0) :else u)))))

(defn- grecond-full-match
  "Method for checking which concept is covering how much"
  [S U n m k]
  (loop [i 0 u U f []]
    (if  (<= k i)
      {:u u :f f}
      (recur 
        (inc i)
        (cond (= (* (count (nth (nth S i) 0)) (count (nth (nth S i) 1)))
                 (:c (grecond-match (grecond-make-matrix-from-concept (nth (nth S i) 0) (nth (nth S i) 1) n m) u)))
          (:u (grecond-match (grecond-make-matrix-from-concept (nth (nth S i) 0) (nth (nth S i) 1) n m) u)) :else u)
        (cond (= (* (count (nth (nth S i) 0)) (count (nth (nth S i) 1)))
                 (:c (grecond-match (grecond-make-matrix-from-concept (nth (nth S i) 0) (nth (nth S i) 1) n m) u)))
          (conj f (nth S i)) :else f)))))

(defn- grecond-remainder-match
  "Method for checking which cocept coveres the most of the remainder context"
  [S U F n m k]
  (loop [i 0 u U f F]
    (if (<= k i)
      [(calc-grecond-context f n m) (make-object f n k) (make-attribute f m k)]
      (recur 
        (inc i)
        (cond
          (< 0 (:c (grecond-match (grecond-make-matrix-from-concept (nth (nth S i) 0) 
                                                                            (nth (nth S i) 1)
                                                                            n
                                                                            m)
                                              u)))
          (:u (grecond-match (grecond-make-matrix-from-concept (nth (nth S i) 0)
                                                                       (nth (nth S i) 1)
                                                                       n
                                                                       m)
                                         u))
          :else u)
        (cond
          (< 0 (:c (grecond-match (grecond-make-matrix-from-concept (nth (nth S i) 0)
                                                                            (nth (nth S i) 1)
                                                                            n
                                                                            m)
                                              u)))
          (conj f (nth S i))
          :else f)))))

(defn- grecond-create-usable
  "Creates for the algorithm usable data from the conexp.fca.contexts/concepts method"
  [S]
  (loop [i 0 c []]
    (if (> i (- (count S) 1))
      c
      (recur
        (inc i)
        (cond
          (not= 0 (* (count (nth (nth S i) 0)) (count (nth (nth S i) 1))))
          (conj c (nth S i))
          :else c)))))

(defn grecond
  "Greedy algorithm which searches for k concepts covering the most incidences."
  [I k]
  (let [S (reverse (sort-by (fn [[a b]] (* (count a) (count b))) (grecond-create-usable (concepts I))))
        U (make-matrix-from-context (context-to-string I))]
    (let [full (grecond-full-match S (into [] (apply concat U)) (count U) (count (get U 0)) k)]
      (grecond-remainder-match (remove (set (:f full)) S) (:u full) (:f full) (count U) (count (get U 0)) k))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; hyper
;; DOI 10.1007/s10618-010-0203-9
(defn- calc-hyper-context
  "Creates Context from hyper-algo result vectors"
  [hyper]
  (make-context-from-matrix  (count (nth hyper 1)) (count (nth (nth hyper 1) 0)) (into [] (flatten (nth hyper 1)))))

(defn- make-object-helper-hyper
  "Helper function for make-object-hyper"
  [concept m k j]
  (loop [i 0 a []]
    (if (<= m i)
      a
      (recur 
        (inc i)
        (cond (some #(= i %) (get (get concept j) :g))
              (conj a 1) :else (conj a 0))))))

(defn- make-object-hyper
  "Creates Object Factorization Context from a given Concept given by Hyper Algo"
  [concept m k]
  (loop [i 0 out []]
    (if (<= k i)
      (make-context-from-matrix m k (into [](flatten (apply mapv vector out))))
      (recur
        (inc i) 
        (conj out (make-object-helper-hyper concept m k i))))))

(defn- make-attribute-hyper
  "Creates Attribute Factorization Context from a given Concept given by Hyper Algo"
  [concept n k]
  (loop [i 0 j 0 out []]
    (if (<= k j)
      (make-context-from-matrix k n out)
      (recur
        (cond (>= i (- n 1)) 0 :else (inc i)) 
        (cond (>= i (- n 1)) (inc j) :else j)
        (cond (some #(= i %) (get (get concept j) :m))
              (conj out 1) :else (conj out 0))))))

(defn- find-hyper
  "Finds all Hyperrectangles and calculates their Coverage in relation to the current Coverage of the Input"
  [C Coverage]
  (let [ret ()]
    (for [c C] (conj ret {:cover (vec (for [x (mapv Coverage (sort (vec (get c 0))))]
                                            (mapv x (sort (vec (get c 1))))))
                          :g (vec (sort (vec (get c 0)))) 
                          :m (vec (sort (vec (get c 1))))}))))

(defn- calc-cover-vector
  "Calculates a vector with the current Coverage"
  [v]
  (loop [i 0 j 0 c 0]
    (if (>= i (count v))
      c
      (recur 
        (cond (> j (count (first (nth v i)))) (inc i) :else i)
        (cond (> j (count (first (nth v i)))) 0 :else (inc j))
        (cond (= (get (first (nth v i)) j) 0) (inc c) :else c)))))

(defn- calc-cost
  "Calcultes the Cost of an Hyperrectangle"
  [hyper]
  (let [v ()]
    (let [sortV (sort-by first (for [x (range (count (get (first hyper) :g)))] (conj v (get (get (first hyper) :g) x)
                                                                                       (get (get (first hyper) :cover ) x))))]
      (loop [i 1 
             out (try (/ (+ (count (first (first sortV))) 1) (calc-cover-vector (conj () (first sortV))))
          (catch ArithmeticException e Integer/MAX_VALUE))
         oldOut Integer/MAX_VALUE g (conj () (nth (first sortV) 1)) oldg ()]
        (if (or (> out oldOut) (>= i (count sortV)))
          (if (> out oldOut)
            {:cost oldOut :g oldg :m (get (first hyper) :m)}
            {:cost out :g g :m (get (first hyper) :m)})
          (recur 
            (inc i)
            (try (/ (+ (count (first (first sortV))) (inc i)) (calc-cover-vector (take (inc i) sortV))) 
                 (catch ArithmeticException e Integer/MAX_VALUE))
            out
            (conj g (nth (nth sortV i) 1))
            g))))))

(defn- calc-cost-list-hyper
  "Puts together a List of all Hyperrectangles and their Cost"
  [C Coverage]
  (let [hyperList (find-hyper C Coverage) costList ()]
    (for [h hyperList] (conj costList (calc-cost h)))))

(defn- calc-new-coverage-hyper
  "Calculates the new Coverage in relation to the new Found Output Hyperrectangle"
  [C Coverage]
  (let [X (apply min 
                (map :cost
                     (into [] (flatten (calc-cost-list-hyper C Coverage)))))
        Y (into [] (flatten (calc-cost-list-hyper C Coverage)))]
    (loop [i 0]
      (if (= (:cost (nth Y i)) X)
        {:m (:m (nth Y i)) :g (:g (nth Y i))}
        (recur (inc i))))))

(defn- create-vector
  "Helper Function to Create a Vector from a Concept"
  [v n]
  (loop [i 0 x [] c 0]
    (if (>= i n)
      x
      (recur 
        (inc i)
        (cond (and  (< c (count v)) (= i (nth v c))) (conj x 1) :else (conj x 0))
        (cond (and (< c (count v)) (= i (nth v c)) ) (inc c) :else c)))))

(defn- calc-new-coverage-matrix-hyper
  "Calculates the new Coverage Matrix in relation to the new Found Output Hyperrectangle"
  [new Coverage n m]
  (unite Coverage (calc-one-matrix (create-vector (into [] (sort (:g new))) m)
                                 (create-vector (into [] (sort (:m new))) n))))

(defn hyper
  "Greedy algorithm, which searches for the concepts which cover the most incidences based on a weighting process."
  [Input k]
  (let [n (count(nth (make-matrix-from-context (context-to-string Input))0))
        m (count (make-matrix-from-context (context-to-string Input)))]
    (loop [Output []
           Coverage (calc-one-matrix (vec (repeat (count (objects Input)) 0)) (vec (repeat(count(attributes Input)) 0))) 
           i 0 
           C (grecond-create-usable (concepts Input))]
        (if (>= i k)
        [(calc-hyper-context [Output Coverage]) (make-object-hyper Output m k) (make-attribute-hyper Output n k)]
        (recur
          (conj Output (calc-new-coverage-hyper C Coverage))
          (calc-new-coverage-matrix-hyper (calc-new-coverage-hyper C Coverage) Coverage n m)
          (inc i) 
          C)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; greess
;; https://doi.org/10.48550/arXiv.1306.4905

(defn- greess-make-matrix-from-concept
  "Creates Context from greess-algo result vectors"
  [a b n m]
  ;; make matrix from concept a&b with n m 
  (loop [i 0 j 0 matrix []]
    (if (> j (- m 1))
    matrix
      (recur 
        (cond (>= i (- n 1)) 0 :else (inc i)) 
        (cond (>= i (- n 1)) (inc j) :else j)
        (cond (and (some #(= j %) a) (some #(= i %) b))
              (conj matrix 1) :else (conj matrix 0))))))

(defn- calc-greess-context
  "Creates Output Context from greess algo output"
  [F n m]
  (loop [i 0 
         end (greess-make-matrix-from-concept (nth (nth F 0) 0) (nth (nth F 0) 1) n m)]
    (if (>= i (count F))
      (make-context-from-matrix m n end)
      (recur
        (inc i)
        (mapv (fn [x y] (if (or (= 1 x) (= 1 y)) 1 0))
              (greess-make-matrix-from-concept (nth (nth F i) 0) (nth (nth F i) 1) n m) end)))))

(defn- cartesian-product
  [a b]
  (for [x a y b] [x y]))

(defn- remove-indexed
  [v n]
  (into (subvec v 0 n) (subvec v (inc n))))

(defn- overlap
  [concepts mark]
  (for [x concepts] (count (intersection (set (cartesian-product (first x) (second x))) (set mark)))))

(defn- overlap-mark
  [concept mark]
  (intersection (set (cartesian-product (first concept) (second concept)))  (set mark) ))

(defn- loop-overlaps
  "Loops over concepts to determine which should be considered a Factorization Candidate"
  [concepts mark k n m]
  (loop [out [] tempConcepts concepts tempMark mark i 0]
    (if (>= i k)
    [(calc-greess-context out m n) (make-object out n k) (make-attribute out m k)]
      (recur
        (conj out (nth tempConcepts (.indexOf (overlap tempConcepts tempMark) (apply max(overlap tempConcepts tempMark)))))
        (remove-indexed tempConcepts (.indexOf (overlap tempConcepts tempMark) (apply max(overlap tempConcepts tempMark))))
        (apply disj (set tempMark)
                    (overlap-mark (nth tempConcepts (.indexOf (overlap tempConcepts tempMark)
                                                             (apply max(overlap tempConcepts tempMark))))
                                 tempMark))
        (inc i)))))

(defn- test-mark
  "Tests wether Incidence should be marked"
  [i j v greek]
  (let [ testGreekGamma (concat (subvec (first greek) 0 i) (subvec (first greek) (inc i)))
         testGreekDelta (concat (subvec (second greek) 0 j) (subvec (second greek) (inc j)))
         gamma (nth (first greek) i)
         delta (nth (second greek) j)]
      (if (and (= 1 (nth (nth v j) i)) (nil?
      (some #(= 1 %) (concat 
        (for [g testGreekGamma] (if (and (subset? g gamma) (= 1 (nth (nth v j) (.indexOf (first greek) g)))) 1 0))
        (for [d testGreekDelta] (if (and (subset? d delta) (= 1 (nth (nth v (.indexOf (second greek) d)) i))) 1 0))))))
        [j i] nil)))

(defn- mark-greess
  "Creates List of Marked Incidences"
  [v greek]
  (loop [marked [] j 0 i 0]
    (if (> (inc j) (count v))
      marked
      (recur 
        (conj marked (test-mark i j v greek))
        (cond (>= (inc i) (count (nth v 0))) (inc j) :else j)
        (cond (>= (inc i) (count (nth v 0))) 0 :else (inc i))))))

(defn- calc-derivation
  "Creates derivation for later use in marking progress"
  [Input x y]
  (loop [gamma [] i 0]
    (if (>= i (count (x Input)))
      gamma
      (recur (conj gamma (y Input #{i})) (inc i)))))

(defn greess
  "Greedy algorithm, which searches for essential incidences and finds concepts covering the most essential incidences."
  [Input k]
  (let [gamma (calc-derivation Input attributes attribute-derivation)
        mu (calc-derivation Input objects object-derivation)
        U (make-matrix-from-context (context-to-string Input))]
    (loop-overlaps (grecond-create-usable (concepts Input))
                  (remove nil? (mark-greess (make-matrix-from-context (context-to-string Input)) [gamma mu]))
                  k
                  (count U)
                  (count (get U 0)))))