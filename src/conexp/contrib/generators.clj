(ns conexp.contrib.generators
  (:use [clojure.contrib.def])
  (:import [java.util.concurrent SynchronousQueue]
	   [java.util NoSuchElementException]))

;;
;; Aim:
;;
;;  user=> (defg generator [x y]
;;           (dotimes [i x]
;;             (dotimes [j y]
;;               (yield (+ i j)))))
;;  #'user/generator
;;  user=> (def gen (generator 3 4))
;;  #'user/gen
;;  user=> (gen)
;;  0
;;  user=> (gen)
;;  1
;;  user=> (generate (generator 2 2))
;;  (0 1 1 2)
;;  user=>
;;

;; be aware of lazy sequences!
;; This does not work:
;;   (generate-by (fn runner [x]
;;                  (for [i (range x)]
;;                    (yield i)))
;;                100)
;;   -> ()
;; but this does:
;;   (generate-by (fn runner [x]
;;                  (doseq [i (range x)]
;;                    (yield i)))
;;                100)
;;   -> (0 1 2 3 ...)

;; Note: Normally generators are "function" returning different values
;; on different calls (hence they are not functions, actually). Here
;; generators are thought of as functions returning "function" which
;; generate the different values. These functions also throw
;; NoSuchElementExceptions when there is nothing left to
;; generate. (See also iterators)

;; Generators

(defmacro- make-generator
  "Creates a generator from the given function definition, which may
  use the function \"yield\". The result may be called with arguments
  to give a function returning all yielded values on subsequent
  calls."
  [function]
  `(fn [& args#]
     (let [#^SynchronousQueue demand-queue# (SynchronousQueue.),   ; send demands to worker thread
	   #^SynchronousQueue delivery-queue# (SynchronousQueue.), ; deliver results to consumer thread
	   end# (atom false),
	   eos# (Object.)]
       (letfn [(~(symbol "yield") [x#]
		(.put delivery-queue# x#)
		(.take demand-queue#))]
	 (.start (Thread. (fn []
			    (.take demand-queue#)
			    (apply ~function args#)
			    (.put delivery-queue# eos#))))
	 (fn []
	   (let [next# (if @end#
			 eos#
			 (let [new# (do
				      (.put demand-queue# 1)
				      (.take delivery-queue#))]
			   (if (= new# eos#)
			     (reset! end# true))
			   new#))]
	     (if @end#
	       (throw
		(java.util.NoSuchElementException. "No more elements to generate."))
	       next#)))))))

(defmacro defg
  "Globally def'ines a generator. When given some arguments a function
  is returned yielding all \"yield\"ed values on subsequent calls. See
  generate and use with care."
  [name args & body]
  `(defn ~name [& args#]
     (let [gen# (make-generator (fn ~name ~args ~@body))]
       (apply gen# args#))))

(defn generate
  "Collects all values generated by the generator into a lazy sequence.

  Example:

    (generate (generator 3 4))
    -> (0 1 2 3 1 2 3 4 2 3 4 5)

  with

    (defg generator [x y]
      (dotimes [i x]
        (dotimes [j y]
          (yield (+ i j)))))
  "
  [generator]
  (let [eos (gensym),
	runner (fn runner []
		 (lazy-seq
		  (let [next-elt (try
				  (generator)
				  (catch NoSuchElementException _
				    eos))]
		    (if (= next-elt eos)
		      nil
		      (cons next-elt (runner))))))]
    (runner)))

(defmacro generate-by
  "Colletcs all values \"yield\"ed by the function. The definition of
  function may use the special function \"yield\" with an additional
  argument. All these values are than collected into a lazy sequence.

  Example:

    (generate-by (fn [x]
                   (doseq [i (range x)]
                     (yield i)))
                 5)
    -> (0 1 2 3 4)

  Note that you have to call yield explicitly. When you wrap a call to
  yield into a lazy sequence this call may not be done at all. For example

    (generate-by (fn [x]
                   (for [i (range x)]
                     (yield i)))
                 5)
    -> ()

  "
  [function & args]
  `(generate ((make-generator ~function) ~@args)))


;; Coroutines

;;
;; Aim:
;;
;; (defcor f []
;;   (dotimes [i 2]
;;     (dotimes [j 10]
;;       (println j))
;;     (yield-to g))
;;
;; (defcor g []
;;   (dotimes [i 2]
;;     (dotimes [j 10]
;;       (println (- 10 j)))
;;     (yield-to f)))
;;
;; Then (f) prints 0 .. 9, 10 .. 1, 0 .. 9, 10 .. 1.
;;
;; Leaving this by now as it is since I don't see any usage for this.

nil
